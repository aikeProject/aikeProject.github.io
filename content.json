{"meta":{"title":"成雨的个人博客","subtitle":"成雨的个人博客","description":"你若化成风，我便化成雨（技术、前端、javascript、vue、react）","author":"成雨","url":"http://blog.rensailong.top","root":"/"},"pages":[],"posts":[{"title":"zepto","slug":"zepto","date":"2019-03-12T15:53:50.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/12/zepto/","link":"","permalink":"http://blog.rensailong.top/2019/03/12/zepto/","excerpt":"","text":"zepto源码 zepto的基本骨架 123456789101112131415161718(function (global, factory) &#123; // 区分当前引用环境 if (typeof define === 'function' &amp;&amp; define.amd) define(function () &#123; return factory(global) &#125;); else factory(global);&#125;)(this, function (window) &#123; // zepto核心代码写在这里面 var zepto = (function () &#123; &#125;)(); // 将zepto挂载到window上，即可以直接使用Zepto或$调用 window.Zepto = Zepto; window.$ === undefined &amp;&amp; (window.$ = Zepto);&#125;); 一些知识点 真伪数组转换 1234567891011121314151617181920212223242526272829// 真数组转化为伪数组var obj = &#123;&#125;;var arr = [1,3,5];[].push.apply(obj,arr);console.log(obj); var arr = []; var obj = &#123; 0:'邵蒙蒙', 1:25, 2:'女', length:3 &#125;; [].push.apply(arr,obj); console.log(arr); // 一般浏览器可以把系统自带的伪数组以及自定义的伪数组转化成真的数组,// 但是在ie8及其以下版本,在ie8以及以下不能通过apply方法把对应的自定义的伪数组转化成对应的值,// 所以我们可以先把伪数组转化成真的数组,然后通过apply方法来设置// 采用slice方法将自定义的伪数组转换为真数组 var obj = &#123; 0:'邵蒙蒙', 1:25, 2:'女', length:3 &#125;; var arr = [].slice.call(obj); console.log(arr); nodeType 节点类型 描述 子节点 Element 代表元素 Element, Text, Comment, ProcessingInstruction, CDATASection, EntityReference Attr 代表属性 Text, EntityReference Text 代表元素或属性中的文本内容。 None CDATASection 代表文档中的 CDATA 部分（不会由解析器解析的文本）。 None EntityReference 代表实体引用。 Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference Entity 代表实体。 Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference ProcessingInstruction 代表处理指令。 None Comment 代表注释。 None Document 代表整个文档（DOM 树的根节点）。 Element, ProcessingInstruction, Comment, DocumentType DocumentFragment 代表轻量级的 Document 对象，能够容纳文档的某个部分 Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference Notation 代表 DTD 中声明的符号。 None ‘readyState’ HTML DOM readyState 属性返回当前文档状态 document.readyState 详见 readyState 返回值 uninitialized 还未开始载入 loading 载入中 interactive 已加载，文档与用户可以交互 complete 载入完成 关于页面加载的一些事件 onload事件，window.onload. 作用: onload事件的实际效果是当页面解析完DOM树，并且完成了所有图片、样式表、脚本等资源的加载后才被触发 DOMContentLoaded, DOM内容加载完后就触发，无需等待其他资源的加载完成。 onreadystatechange 低版本ie不支持DOMContentLoaded，可以用onreadystatechange代替 doScroll 低于ie8,可以通过每隔一段时间执行一次document.documentElement.doScroll(“left”)来检测这一状态，因为这条代码在DOM加载完毕之前执行时会抛出错误(throw an error) setTimeout(fn, 0)的应用 详见 12345678910111213setTimeout(fn, 0)的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(fn, 0);document.getElementById(&quot;haoroomsID&quot;).onclick = function A() &#123; setTimeout(function B() &#123; console.log(&quot;触发子元素事件&quot;) &#125;, 0)&#125;;document.body.onclick = function C() &#123; console.log(&quot;触发父元素事件&quot;)&#125;;点击haoroomsID会先触发父级元素事件，然后再触发子元素事件 init初始化函数入口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387// @author 成雨// @date 2017/12/21// @Description: zepto.js// zepto核心代码写在这里面var Zepto = (function () &#123; var $, zepto = &#123;&#125;; var emptyArray = []; var sconcat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice; // 正则表达式 // 类似于这样的'&lt;html&gt;', '&lt;html&gt;d&lt;/html&gt;'会被匹配，html片段 var fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/, // '&lt;html&gt;&lt;/html&gt;' '&lt;html&gt;' '&lt;html/&gt;' 将会被匹配 singleTagRE = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;|)$/, // 匹配这样的内容 '&lt;div id=\"dddd\"/&gt; &lt;p /&gt;' tagExpanderRE = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/ig, simpleSelectorRE = /^[\\w-]*$/; // 设置属性 var methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset']; var table = document.createElement('table'), tableRow = document.createElement('tr'), containers = &#123; 'tr': document.createElement('tbody'), 'tbody': table, 'thead': table, 'tfoot': table, 'td': tableRow, 'th': tableRow, '*': document.createElement('div') &#125;; var isArray = Array.isArray || function (object) &#123; return object instanceof Array &#125;; var class2type = &#123;&#125;, toString = class2type.toString; var camelize, uniq; //TODO 类型检测的方法 function type(obj) &#123; // 第一次调用都会返回‘object’ return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\" &#125; //TODO isFunction 检测是否是函数 function isFunction(value) &#123; return type(value) == 'function' &#125; //TODO 判断是不是 'window'对象 window == window.window -&gt; true function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window &#125; function isObject(obj) &#123; return type(obj) == \"object\" &#125; //TODO 纯对象 function isPlainObject(obj) &#123; return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype &#125; // 判断是不是伪数组 // TODO likeArray 伪数组 function likeArray(obj) &#123; var length = !!obj &amp;&amp; 'length' in obj &amp;&amp; obj.length, type = $.type(obj); return 'function' != type &amp;&amp; !isWindow(obj) &amp;&amp; ( 'array' == type || length === 0 || (typeof length == 'number' &amp;&amp; length &gt; 0 &amp;&amp; (length - 1) in obj) ) &#125; function compact(array) &#123; return filter.call(array, function (item) &#123; return item != null &#125;) &#125; // 将一组字符串变成“骆驼”命名法的新字符串，如果该字符已经是“骆驼”命名法，则不变化。 camelize = function (str) &#123; return str.replace(/-+(.)?/g, function (match, chr) &#123; // toUpperCase首字母大写 return chr ? chr.toUpperCase() : ''; &#125;); &#125;; // 将dom挂载到Z对象实例上 function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0; for (i = 0; i &lt; len; i++) this[i] = dom[i]; this.length = len; this.selector = selector || ''; &#125; // 接受一个html字符串和一个可选的标签名 // 从给定的html字符串生成DOM节点 // 生成的DOM节点作为数组返回 // html 标签字符串 name 标签名 properties 属性对象 zepto.fragment = function (html, name, properties) &#123; var dom, nodes, container; // 空标签将会被匹配 // '&lt;div&gt;&lt;/div&gt;' '&lt;div&gt;' '&lt;div/&gt;' 将会被匹配 其中'RegExp.$1'的$1代表了'html' if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1)); // 如果不符合上一个条件 if (!dom) &#123; // '&lt;div id=\"dddd\"/&gt; &lt;p /&gt;' 将转换为 '&lt;div id=\"dddd\"&gt;&lt;/div&gt; &lt;p &gt;&lt;/p&gt;' if (html.replace) html = html.replace(tagExpanderRE, \"&lt;$1&gt;&lt;/$2&gt;\"); // 获取到标签名 比如'&lt;div id=\"dddd\"/&gt; &lt;p /&gt;' -&gt; name = div(RegExp.$1) if (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1; // 根据'containers'的内容来确定要用来包裹内容的元素 if (!(name in containers)) name = '*'; container = containers[name]; container.innerHTML = '' + html; // TODO slice.call 真伪数组转换 // container.childNodes伪数组 这里是将伪数组转化真数组 dom = $.each(slice.call(container.childNodes), function () &#123; container.removeChild(this); &#125;); &#125; // TODO $('&lt;div&gt;&lt;/div&gt;', &#123;height: '10px'&#125;) 如果是一个纯对象 // 作用就是将其添加到创建好的dom里面 if (isPlainObject(properties)) &#123; // zepto对象 nodes = $(dom); $.each(properties, function (key, value) &#123; // ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'] // 如果是设置这些属性，调用定义在zepto的方法进行设置 if (methodAttributes.indexOf(key) &gt; -1) &#123; nodes[key](value); &#125; // attr方法进行设置 else &#123; nodes.attr(key, value); &#125; &#125;); &#125; return dom; &#125;; // 实例化Z构造函数 zepto.Z = function (dom, selector) &#123; return new Z(dom, selector); &#125;; //isZ 其中 instanceof 可检测对象是否在对象的上或者其原型上 zepto.isZ = function (object) &#123; return object instanceof zepto.Z; &#125;; // TODO 选择器方法 // 作用： // '#id' -&gt; document.getElementById // '.class' -&gt; document.getElementsByClassName // 'div' -&gt; document.getElementsByTagName // '其他' -&gt; document.querySelectorAll zepto.qsa = function (element, selector) &#123; var found, maybeID = selector[0] == '#', maybeClass = !maybeID &amp;&amp; selector[0] == '.', nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, isSimple = simpleSelectorRE.test(nameOnly); if (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) &#123; found = element.getElementById(nameOnly); if (found) &#123; return [found]; &#125; else &#123; return []; &#125; &#125; else &#123; if (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) &#123; return []; &#125; else &#123; return slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? maybeClass ? element.getElementsByClassName(nameOnly) : element.getElementsByTagName(selector) : element.querySelectorAll(selector) ) &#125; &#125; &#125;; // TODO 初始化函数 init // selector 传入的选择器 // 'init'主要做的事情就是根据传入的'selector'类型，分别判断执行不同的任务 zepto.init = function (selector, context) &#123; var dom; // 如果未传入参数'selector' // 如果什么都没有给出，返回一个空的Zepto集合 // zepto.Z()将创建一个空的对象集合 if (!selector) return zepto.Z(); // 如果'selector'传入字符串 else if (typeof selector == 'string') &#123; // 去除前后空格 selector = selector.trim(); // 判断‘selector’是不是一个标签字符串 if (selector[0] == '&lt;' &amp;&amp; fragmentRE.test(selector)) &#123; dom = zepto.fragment(selector, RegExp.$1, context), selector = null &#125; // 如果有上下文，要在上下文里查找 else if (context !== undefined) return $(context).find(selector); // TODO css选择器 else &#123; dom = zepto.qsa(document, selector) &#125; &#125; // 如果传入的是一个函数‘function’，该函数在dom加载完时调用,这个就是平时我们用的jquery的ready函数 else if (isFunction(selector)) &#123; return $(document).ready(selector); &#125; // 传入对象是不是zepto对象 else if (zepto.isZ(selector)) &#123; return selector; &#125; else &#123; // 传入数组 if (isArray(selector)) dom = compact(selector); // 传入一个对象 else if (isObject(selector)) &#123; dom = [selector], selector = null; &#125; // 传入html片段 else if (fragmentRE.test(selector)) &#123; dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null &#125; // 是否传入上下文 else if (context !== undefined) &#123; return $(context).find(selector) &#125; // 是一个选择器 else &#123; dom = zepto.qsa(document, selector) &#125; &#125; // 最后将找到的dom转化为zepto对象 return zepto.Z(dom, selector) &#125;; // 调用`zepto.init`进行初始化 $ = function (selector, context) &#123; return zepto.init(selector, context) &#125;; // 将一个对象复制到另一个目标对象上 function extend(target, source, deep) &#123; for (key in source) &#123; // 深拷贝 if (deep &amp;&amp; (isPlainObject(source[key])) || isArray(source[key])) &#123; if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) &#123; target[key] = &#123;&#125;; &#125; if (isArray(source[key]) &amp;&amp; !isArray(target[key])) &#123; target[key] = []; &#125; extend(target[key], source[key], deep); &#125; // 浅拷贝 else if (source[key] !== undefined) &#123; target[key] = source[key]; &#125; &#125; &#125; // 通过源对象扩展目标对象的属性，源对象属性将覆盖目标对象属性。 // 默认情况下为，复制为浅拷贝（浅复制）。如果第一个参数为true表示深度拷贝（深度复制）。 $.extend = function (target) &#123; var deep, args = slice.call(arguments, 1); if (typeof target == 'boolean') &#123; deep = target; target = args.shift(); &#125; args.forEach(function (org) &#123; extend(target, org, deep) &#125;); return target; &#125;; // 工具方法 // TODO 类型检测 $.type = type; $.isFunction = isFunction; $.isWindow = isWindow; $.isArray = isArray; $.isPlainObject = isPlainObject; // 如果该值为有限数值或一个字符串表示的数字，则返回ture。 $.isNumeric = function (val) &#123; var num = Number(val), type = typeof val; return val != null &amp;&amp; type != 'boolean' &amp;&amp; (type != 'string' || val.length) &amp;&amp; !isNaN(num) &amp;&amp; isFinite(num) || false &#125;; // $.inArray(element, array, [fromIndex]) ⇒ number // 返回数组中指定元素的索引值（注：以0为基数），如果没有找到该元素则返回-1。 $.inArray = function (elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i); &#125;; // 驼峰 命名转化 $.camelCase = camelize; // TODO 遍历 each $.each = function (elements, callback) &#123; var i, key; if (likeArray(elements)) &#123; // 用数组的循环方法 for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; // 用对象的循环方法 else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements; &#125;; // $.grep(items, function(item)&#123; ... &#125;) ⇒ array // 获取一个新数组，新数组只包含回调函数中返回 ture 的数组项。 // 同 filter()方法 $.grep = function (element, callback) &#123; return filter.call(element, callback); &#125;; // Populate the class2type map // 第一次调用 ‘$.each’ 给 'class2type' 赋值, 类型检测的运用 $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (i, name) &#123; class2type[\"[object \" + name + \"]\"] = name.toLowerCase(); &#125;); // TODO s.fn 定义所有可用方法 // Zepto.fn是一个对象，它拥有Zepto对象上所有可用的方法，如 addClass()， attr()，和其它方法。在这个对象添加一个方法，所有的Zepto对象上都能用到该方法。 $.fn = &#123; // 将其指向 zepto.Z 这个函数 constructor: zepto.Z, length: 0, // dom加载完毕的检测函数 // 详见 https://segmentfault.com/a/1190000005869515 // TODO ready ready: function (callback) &#123; // 详见README readyState 的几个状态 // document.documentElement.doScroll 这句话作用是非ie，也就是这里ie不支持 if (document.readyState === 'complete' || (document.readyState === 'loading' &amp;&amp; !document.documentElement.doScroll)) &#123; // setTimeout(fn, 0)的应用 详见 https://blog.csdn.net/jingtian678/article/details/79547596 setTimeout(function () &#123; callback($); &#125;, 0); &#125; else &#123; var handler = function () &#123; document.removeEventListener('DOMContentLoaded', handler, false); window.removeEventListener('load', handler, false); callback($); &#125;; document.addEventListener('DOMContentLoaded', handler, false); window.addEventListener('load', handler, false); &#125; &#125;, &#125;; // 这里就是将‘$.fn’ 添加到 ‘zepto.Z’的原型上 和 ‘Z’的原型上 zepto.Z.prototype = Z.prototype = $.fn; return $;&#125;)();// 将zepto挂载到window上，即可以直接使用Zepto或$调用window.Zepto = Zepto;window.$ === undefined &amp;&amp; (window.$ = Zepto);","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"zepto","slug":"zepto","permalink":"http://blog.rensailong.top/tags/zepto/"},{"name":"js","slug":"js","permalink":"http://blog.rensailong.top/tags/js/"}]},{"title":"Selenium","slug":"Selenium","date":"2019-03-07T15:24:39.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/07/Selenium/","link":"","permalink":"http://blog.rensailong.top/2019/03/07/Selenium/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://blog.rensailong.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://blog.rensailong.top/tags/python/"}]},{"title":"pyquery","slug":"pyquery","date":"2019-03-07T15:21:53.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/07/pyquery/","link":"","permalink":"http://blog.rensailong.top/2019/03/07/pyquery/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://blog.rensailong.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://blog.rensailong.top/tags/python/"}]},{"title":"regex正则","slug":"regex正则","date":"2019-03-07T15:20:23.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/07/regex正则/","link":"","permalink":"http://blog.rensailong.top/2019/03/07/regex正则/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://blog.rensailong.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://blog.rensailong.top/tags/python/"}]},{"title":"requests","slug":"requests","date":"2019-03-07T15:18:10.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/07/requests/","link":"","permalink":"http://blog.rensailong.top/2019/03/07/requests/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://blog.rensailong.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://blog.rensailong.top/tags/python/"}]},{"title":"urllib","slug":"urllib","date":"2019-03-07T15:15:18.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/07/urllib/","link":"","permalink":"http://blog.rensailong.top/2019/03/07/urllib/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://blog.rensailong.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://blog.rensailong.top/tags/python/"}]},{"title":"前端面试题","slug":"前端面试题","date":"2019-03-06T14:48:14.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/06/前端面试题/","link":"","permalink":"http://blog.rensailong.top/2019/03/06/前端面试题/","excerpt":"","text":"面试题（答案尚未整理完） react 生命周期 生命周期图 生命周期主要分为：挂载、更新、卸载、异常（新增） 挂载阶段 constructor(初始化) 初始化state、给方法绑定this static getDerivedStateFromProps 使用props给state赋值,有了这个方法就不需要再用componentWillReceiveProps来更新props了 123456789101112class C extends React.Component &#123; state = &#123; y: 0 &#125; static getDerivedStateFromProps(props, state): State &#123; if(props.y !== state.y) &#123; return &#123; y: props.y &#125;; &#125; &#125;&#125; render 渲染组件 componentDidMount 组件渲染之后调用（dom更新完之后）只调用一次 更新阶段 static getDerivedStateFromProps shouldComponentUpdate 决定组件的更新 、性能优化 render 渲染组件 getSnapshotBeforeUpdate dom更新之前调用，此时state已更新； 返回值作为componentDidUpdate的第3个参数； 一般用于获取render之前的 DOM 数据 12345678class C extends React.Component &#123; getSnapshotBeforeUpdate (prevProps, prevState): Snapshot &#123; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // snapshot 是从 getSnapshotBeforeUpdate 的返回值，默认是 null &#125;&#125; componentDidUpdate 组件渲染之后调用（dom更新完之后） 卸载阶段 componentWillUnmount 异常 class PotentialError extends React.Component { state = { error: false, } componentDidCatch(error, info) { console.error(info); this.setState({ error }); } render() { if (this.state.error) { return &lt;h1&gt;出错了，请打卡控制台查看详细错误！&lt;/h1&gt;; } return this.props.children; } } const Demo = () =&gt; ( &lt;PotentialError&gt; &lt;div&gt;{{a: 1}}&lt;/div&gt; &lt;/PotentialError&gt; ) 完整的生命周期 import React from 'react' export default class MyComponent extends React.Component { constructor(props) { super(props); // 初始化state方式（1） this.state = { } } // 默认的 props 值 static defaultProps = { } // 初始化state方式（2） state = { } /** * 作用：避免使用props给state赋值 * 挂载组件时，该静态方法会在render前执行；更新组件时，该静态方法会在shouldComponentUpdate前执行 * getDerivedStateFromProps的返回值将作为setState的参数，如果返回null，则不更新state，不能返回object 或 null 以外的值，否则会警告 */ static getDerivedStateFromProps(props, state) { return state } // 组件树的异常捕获 componentDidCatch(error, info) { } // 组件渲染 render() { } // dom渲染完毕 只调用一次 componentDidMount() { } // 影响组件更新 性能优化 shouldComponentUpdate(nextProps, nextState) { } // dom更新之前调用，此时`state`已更新 getSnapshotBeforeUpdate(prevProps, prevState) { } // dom渲染完毕 componentDidUpdate(prevProps, prevState, snapshot) { } // 组件卸载 componentWillUnmount() { } } redux用过没有 redux-trunk原理。 es6打包后装垫片文件太大，可能只用到了其中有几个功能，如何减少体积。 underscore的indexBy实现。自己如何来实现。用reduce 通过一个参数控制表单一行两列和一行一列的切换。 flex布局的垂直居中，水平居中。 antd有没用过。 做过哪个前端性能上的优化。 你的公共组件的样式是如何存放的。 取杨辉三角的m行n列的值的实现。关键代码即可。 有序链表合并。用java。不过说js也行。不要求能跑 react的循环中的key的作用。越详细越好。 setState的异步执行和同步执行。 echarts的地图上省会坐标是怎么定那个点的(我说是地图自己提供了每个城市的坐标，我感觉是他没用过就顺便问了一下) 未来的工作生活的打算 薪资和期望薪资 往年绩效 工作经历 换工作的原因 哪里关注新技术 遇到过最大的挫折 最有成就感得事 这几年工作对你的影响。 有哪些优点哪些不足 项目中的问题: 我的jssdk的实现原理。 如何设计你的框架的。 技术为什么选react react的生命周期 setState可以在哪里改变 setState的批量更新是怎么实现的 发起异步请求在哪些生命周期里。(要说出16版本的react里willmount可能会执行多次，这里不能发起，好像能把面试官唬住)。 子父，兄弟，父子，孙子关系节点的通讯方式。要提到context。 如何设计一个输入筛选组件 用redux和不用 提升性能方面做过什么 自己的优势劣势 pc和移动端开发上有什么区别。 flex布局用在了哪里。 有关注哪些新技术 可以说pwa webasm这些。 哪里关注新技术 项目中的问题 jssdk里的实现方式。 项目里做了什么优化 jssdk里怎么做兼容性的 jssdk的整个系统的一个流程。包括前端实现过程和后台服务过程。 为什么选react","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://blog.rensailong.top/tags/面试题/"}]},{"title":"beautifulsoup","slug":"beautifulsoup","date":"2019-03-06T14:42:45.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/06/beautifulsoup/","link":"","permalink":"http://blog.rensailong.top/2019/03/06/beautifulsoup/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.rensailong.top/tags/python/"},{"name":"beautifulsoup","slug":"beautifulsoup","permalink":"http://blog.rensailong.top/tags/beautifulsoup/"}]},{"title":"scrapy","slug":"scrapy","date":"2019-03-06T14:26:57.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/06/scrapy/","link":"","permalink":"http://blog.rensailong.top/2019/03/06/scrapy/","excerpt":"","text":"官方地址安装1conda install scrapy 创建一个项目 scrapy startproject myproject [project_dir] cd project_dir scrapy genspider mydomain mydomain.com 基本使用 通过scrapy genspider zhihu www.zhihu.com在spiders文件夹下生产爬取逻辑的代码文件 通过例子看基本使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# zhihu.py 通过 scrapy genspider zhihu www.zhihu.com 创建的# 写主要的爬虫逻辑# 这个例子是爬取知乎用户的关注人，关注人的关注人，一直递归下去# -*- coding: utf-8 -*-import jsonimport scrapyfrom tutorial.items import UserItem# 爬取知乎需要添加一些请求头信息# 打开setting.py中的 DEFAULT_REQUEST_HEADERS并添加user-agentclass ZhihuSpider(scrapy.Spider): name = 'zhihu' allowed_domains = ['www.zhihu.com'] start_urls = ['http://www.zhihu.com/'] # 初始爬取的用户token_url，看一下知乎的请求链接结构就知道这个是用来干啥的了，其实就是用来标识每一个用户 start_user = 'Talyer-Wei' # 请求用户详细信息 user_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;?include=&#123;include&#125;' # 请求关注用户列表 follows_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;/followees?include=&#123;include&#125;&amp;offset=&#123;offset&#125;&amp;limit=&#123;limit&#125;' # 这个是粉丝列表请求，爬取和爬关注用户是一样逻辑，没写 # followers_url = 'https://www.zhihu.com/api/v4/members/&#123;user&#125;/followers?include=&#123;include&#125;&amp;offset=&#123;offset&#125;&amp;limit=&#123;limit&#125;' # follows_url中include的参数 user_query = 'allow_message%2Cis_followed%2Cis_following%2Cis_org%2Cis_blocking%2Cemployments%2Canswer_count%2Cfollower_count%2Carticles_count%2Cgender%2Cbadge%5B%3F(type%3Dbest_answerer)%5D.topics' # follows_url中include的请求参数 follows_query = 'data%5B*%5D.answer_count%2Carticles_count%2Cgender%2Cfollower_count%2Cis_followed%2Cis_following%2Cbadge%5B%3F(type%3Dbest_answerer)%5D.topics' # 重写启动请求 def start_requests(self): # 爬取个人信息 yield scrapy.Request( self.user_url.format( user=self.start_user, include=self.user_query ), callback=self.parse_user ) # 爬取初始的关注用户 yield scrapy.Request( self.follows_url.format( user=self.start_user, include=self.follows_query, offset=0, limit=20 ), callback=self.parse_follows ) # 请求回调 def parse_user(self, response): result = json.loads(response.text) item = UserItem() for field in item.fields: if field in result.keys(): item[field] = result[field] yield item # 爬取个人的详细信息 yield scrapy.Request( self.follows_url.format( user=result.get('url_token'), include=self.follows_query, offset=0, limit=20 ), callback=self.parse_follows ) # 爬取关注自己的人 def parse_follows(self, response): results = json.loads(response.text) # 再递归爬取关注自己人的，他的关注信息，就这样一直递归下去 if 'data' in results.keys(): for result in results.get('data'): yield scrapy.Request( url=self.user_url.format( user=result.get('url_token'), include=self.user_query ), callback=self.parse_user ) # 分页还未结束继续查找分页 if 'paging' in results.get('paging') and results.get('paging').get('is_end') == False: next_page = results.get('paging').get('next') yield scrapy.Request( url=next_page, callback=self.parse_follows ) 定义 items，相当于要保存数据的模型，通过items.py配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# https://doc.scrapy.org/en/latest/topics/items.htmlfrom scrapy import Item, Fieldclass UserItem(Item): # define the fields for your item here like: # name = scrapy.Field() id = Field() name = Field() avatar_url = Field() headline = Field() description = Field() url = Field() url_token = Field() gender = Field() cover_url = Field() type = Field() badge = Field() answer_count = Field() articles_count = Field() commercial_question_count = Field() favorite_count = Field() favorited_count = Field() follower_count = Field() following_columns_count = Field() following_count = Field() pins_count = Field() question_count = Field() thank_from_count = Field() thank_to_count = Field() thanked_count = Field() vote_from_count = Field() vote_to_count = Field() voteup_count = Field() following_favlists_count = Field() following_question_count = Field() following_topic_count = Field() marked_answers_count = Field() mutual_followees_count = Field() hosted_live_count = Field() participated_live_count = Field() locations = Field() educations = Field() employments = Field() pass pipelines.py 在这个文件夹中，将items存入数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-# Define your item pipelines here## Don&apos;t forget to add your pipeline to the ITEM_PIPELINES setting# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html# class TutorialPipeline(object):# def process_item(self, item, spider):# return itemimport pymongo# 保存到MongoDB数据库class MongoPipeline(object): collection_name = &apos;users&apos; # 初始化数据库 def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db #获取全局setting设置 @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get(&apos;MONGO_URI&apos;), mongo_db=crawler.settings.get(&apos;MONGO_DATABASE&apos;) ) # 连接数据库 # open_spider spider 启动 def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] # close_spider 关闭 # 关闭数据库链接 def close_spider(self, spider): self.client.close() # 存入数据 def process_item(self, item, spider): # 更新去重 self.db[self.collection_name].update(&#123;&apos;url_token&apos;: item[&apos;url_token&apos;]&#125;, dict(item), True) return item","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://blog.rensailong.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://blog.rensailong.top/tags/python/"},{"name":"scrapy","slug":"scrapy","permalink":"http://blog.rensailong.top/tags/scrapy/"}]},{"title":"gulp","slug":"gulp","date":"2019-03-05T20:27:01.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/gulp/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/gulp/","excerpt":"","text":"gulp 1、gulp的安装 全局方式安装gulpnpm install -g gulp 如果想在安装的时候把gulp写进项目package.json文件的依赖中npm install --save-dev gulp 2、开始使用gulp 2.1 建立gulpfile.js文件 2.2 运行gulp任务gulp 3、我们将要使用Gulp插件来完成我们以下任务： sass的编译（gulp-ruby-sass） 自动添加css前缀（gulp-autoprefixer） 压缩css（gulp-minify-css） js代码校验（gulp-jshint） 合并js文件（gulp-concat） 压缩js代码（gulp-uglify） 压缩图片（gulp-imagemin） 自动刷新页面（gulp-livereload） 图片缓存，只有图片替换了才压缩（gulp-cache） 更改提醒（gulp-notify） 清除文件（del） 浏览器同步(‘browser-sync’) 安装这些插件需要运行如下命令：1npm install gulp-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev 加载插件123456789101112131415gulp = require('gulp'), // sass = require('gulp-ruby-sass'),需要ruby环境，需要生成临时目录和文件 sass = require('gulp-sass'),// 调用node-sass 有node.js就可以，编译过程不需要生成临时目录和文件 autoprefixer = require('gulp-autoprefixer'),// 自动添加css前缀 cssnano = require('gulp-cssnano'),// jshint = require('gulp-jshint'),// 代码检测工具 uglify = require('gulp-uglify'),// 压缩js代码 imagemin = require('gulp-imagemin'),// 压缩图片 rename = require('gulp-rename'),// 重命名 concat = require('gulp-concat'),// 合并js文件 notify = require('gulp-notify'),// 更改提醒 cache = require('gulp-cache'),// 缓存通知 livereload = require('gulp-livereload'), del = require('del'),// 清除文件 browserSync = require('browser-sync'); // 浏览器同步 建立任务 编译sass、自动添加css前缀和压缩12345678910111213// 编译sass、自动添加css前缀和压缩gulp.task('styles', function () &#123; //sass()方法用于转换sass到css return gulp.src('src/styles/main.scss') .pipe(sass()) .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4')) // 自动添加css前缀 .pipe(gulp.dest('dist/assets/css')) // 处理后文件存放地址 .pipe(gulp.dest('src/css')) .pipe(rename(&#123;suffix: '.min'&#125;)) // 重命名 .pipe(cssnano()) .pipe(gulp.dest('dist/assets/css')) .pipe(notify(&#123;message: 'sass task complete'&#125;));// 更改提醒&#125;); gulp.task() 这个API用来创建任务，在命令行下可以输入$ gulp styles来执行上面的任务 gulp.src() 这个API设置需要处理的文件的路径，可以是多个文件以数组的形式[main.scss, vender.scss]，也可以是正则表达式/*/.scss .pipe() 将需要处理的文件导向sass插件 gulp.dest() 设置生成文件的路径，一个任务可以有多个生成路径，一个可以输出未压缩的版本，另一个可以输出压缩后的版本 js代码校验、合并和压缩123456789101112// js代码校验、合并和压缩gulp.task('scripts', function () &#123; return gulp.src('src/scripts/**/*.js') .pipe(jshint('config.jshintrc')) .pipe(jshint.reporter('default')) .pipe(concat('main.js')) .pipe(gulp.dest('dist/assets/js')) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(uglify()) .pipe(gulp.dest('dist/assets/js')) .pipe(notify(&#123;message: 'Scripts task complete'&#125;));&#125;); 压缩图片1234567// 压缩图片gulp.task(&apos;images&apos;, function () &#123; return gulp.src(&apos;src/images/**/*&apos;) .pipe(cache(imagemin(&#123;optimizationLevel: 5, progressive: true, interlaced: true&#125;))) .pipe(gulp.dest(&apos;dist/assets/img&apos;)) .pipe(notify(&#123;message: &apos;Images task complete&apos;&#125;));&#125;); 清除文件1234// 清除文件gulp.task(&apos;clean&apos;, function (cb) &#123; del([&apos;dist/assets/css&apos;, &apos;dist/assets/js&apos;, &apos;dist/assets/img&apos;], cb)&#125;); 处理html123456// 处理htmlgulp.task(&apos;html&apos;, function () &#123; return gulp.src(&apos;src/index.html&apos;) .pipe(gulp.dest(&apos;dist/assets/&apos;)) .pipe(notify(&#123;message: &apos;index-html task complete&apos;&#125;));&#125;); 设置默认任务（default）12345678910111213141516// 设置默认任务（default）gulp.task(&apos;default&apos;, function () &#123; // gulp.start(&apos;browser-sync&apos;, &apos;styles&apos;, &apos;scripts&apos;, &apos;images&apos;, &apos;html&apos;); // Watch .scss files gulp.watch(&apos;src/styles/!**!/!*.scss&apos;, [&apos;styles&apos;]); // Watch .js files gulp.watch(&apos;src/scripts/!**!/!*.js&apos;, [&apos;scripts&apos;]); // Watch image files gulp.watch(&apos;src/images/!**!/!*&apos;, [&apos;images&apos;]); // watch html files gulp.watch(&apos;src/index.html&apos;, [&apos;html&apos;]);&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://blog.rensailong.top/tags/gulp/"}]},{"title":"flex","slug":"flex","date":"2019-03-05T20:23:09.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/flex/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/flex/","excerpt":"","text":"6个属性设置在容器上123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 1.flex-direction 项目的排列方向1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 2.flex-wrap 换行123nowrap（默认） 不换行wrap 换行wrap-reverse 换行，第一行下方（反向换行） 3.flex-flow （是上两个属性的简写） 4.justify-content 水平对齐方式 12345flex-start 左对齐flex-end 右对齐center 居中对齐space-between 两端对齐space-around 等分对齐 5.align-items （垂直对齐方式）12345flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6.aligin-content （类似于水平对齐 justify-content ） 123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 6个项目属性 123456orderflex-growflex-shrinkflex-basisflexalign-self 1234567891.order 项目排列顺序 越小越靠前 默认为02.flex-grow 项目放大比例 默认为0 0 即不放大3.flex-shrink 项目缩小比例 默认为1 1 即如果空间不足，将缩小4.flex-basis 固定空间 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间5.flex 是flex-grow, flex-shrink 和 flex-basis的简写 默认值 0 0 auto （推荐使用）6.aligin-self 允许单个项目有与其他项目不一样的对齐方式除了auto，其他都与align-items属性完全一致默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://blog.rensailong.top/tags/flex/"},{"name":"css","slug":"css","permalink":"http://blog.rensailong.top/tags/css/"}]},{"title":"fetch的使用","slug":"fetch的使用","date":"2019-03-05T20:21:53.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/fetch的使用/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/fetch的使用/","excerpt":"","text":"fetch 的使用 fetch的作用 XMLHttpRequest的最新替代技术——FetchAPI，它是W3C的正式标准，本文将会介绍Fetch API的相关知识，以及探讨它所能使用的场景和能解决的问题。fetch就是一种可代替ajax获取/提交数据的技术，有些高级浏览器已经可以window.fetch使用了。相比于使用jQuery.ajax它轻量（只做这一件事），而且它原生支持 promise ，更加符合现在编程习惯 fetch的安装 npm install whatwg-fetch --save npm install es6-promise --save 兼容老版本浏览器 promise 使用语法 12345fetch(url, options).then(function(response) &#123; // handle HTTP response&#125;, function(error) &#123; // handle network error&#125;) options（可选） 12345678一个配置项对象，包括所有对请求的设置。可选的参数有：method: 请求使用的方法，如 GET、POST。headers: 请求的头信息，形式为 Headers 对象或 ByteString。body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。mode: 请求的模式，如 cors、 no-cors 或者 same-origin。credentials: 请求的 credentials，如 omit、same-origin 或者 include。cache: 请求的 cache 模式: default, no-store, reload, no-cache, force-cache, 或者 only-if-cached。 response 参数 1234567891011121314151617181920一个 Promise，resolve 时回传 Response 对象：属性status (number) - HTTP请求结果参数，在100–599 范围statusText (String) - 服务器返回的状态报告ok (boolean) - 如果返回200表示请求成功则为trueheaders (Headers) - 返回头部信息，下面详细介绍url (String) - 请求的地址方法：text() - 以string的形式生成请求textjson() - 生成JSON.parse(responseText)的结果blob() - 生成一个BlobarrayBuffer() - 生成一个ArrayBufferformData() - 生成格式化的数据，可用于其他的请求其他方法：clone()Response.error()Response.redirect() response.headers 1234567has(name) (boolean) - 判断是否存在该信息头get(name) (String) - 获取信息头的数据getAll(name) (Array) - 获取所有头部数据set(name, value) - 设置信息头的参数append(name, value) - 添加header的内容delete(name) - 删除header的信息forEach(function(value, name)&#123; ... &#125;, [thisContext]) - 循环读取header的信息 get 请求 JSON 12345678fetch(url) // 传入url get请求 .then(function(response) &#123; return response.json(); // 返回json数据 &#125;).then(function(data) &#123; console.log(data); // 取得json数据 &#125;).catch(function(e) &#123; console.log(&quot;Oops, error&quot;);// 错误异常 &#125;); 使用ES6写法 1234fetch(url) .then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log(&quot;Oops, error&quot;, e)) post 请求 json1234567891011fetch(&apos;/users&apos;, &#123; method: &apos;POST&apos;,// 请求方式 headers: &#123; // 设置请求头 &apos;Accept&apos;: &apos;application/json&apos;, &apos;Content-Type&apos;: &apos;application/json&apos; &#125;, body: JSON.stringify(&#123; name: &apos;Hubot&apos;, login: &apos;hubot&apos;, &#125;)&#125;) promise (es6) Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve方法和reject方法。如果异步操作成功，则用resolve方法将Promise对象的状态变为“成功”（即从pending变为resolved）；如果异步操作失败，则用reject方法将状态变为“失败”（即从pending变为rejected） promise实例生成以后，可以用then方法分别指定resolve方法和reject方法的回调函数12345678910111213141516//创建一个promise对象var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);//then方法可以接受两个回调函数作为参数。//第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。//其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"fetch","slug":"fetch","permalink":"http://blog.rensailong.top/tags/fetch/"}]},{"title":"editorconfig配置文件","slug":"editorconfig配置文件","date":"2019-03-05T20:19:46.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/editorconfig配置文件/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/editorconfig配置文件/","excerpt":"","text":"配合编辑器插件使用 例如： Visual Studio Code ： EditorConfig 12345678910111213141516171819202122232425262728293031323334353637383940# editorconfig.orgroot = true[*]# 缩进使用tab键indent_style = tab# tab长度tab_width = 4# 空格长度indent_size = 2# 换行符类型end_of_line = lf# 文件的编码charset = utf-8# 自动删除行尾空格trim_trailing_whitespace = true# 以一个空白符结尾insert_final_newline = true[*.md]# .md文件保留行尾空格trim_trailing_whitespace = false# * 匹配除/之外的任意字符# ** 匹配任意字符串# ? 匹配任意单个字符# [name] 匹配name字符# [!name] 不匹配name字符# [s1,s2,s3] 匹配给定的字符串# [num1..num2] 匹配num1到mun2直接的整数# indent_style 缩进使用tab或者space# indent_size 缩进为space时，缩进的字符数# tab_width 缩进为tab时，缩进的宽度# end_of_line 换行符的类型。lf, cr, crlf三种# charset 文件的charset。有以下几种类型：latin1, utf-8, utf-8-bom, utf-16be, utf-16le# trim_trailing_whitespace 是否将行尾空格自动删除# insert_final_newline 是否使文件以一个空白行结尾# root 表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"editorconfig","slug":"editorconfig","permalink":"http://blog.rensailong.top/tags/editorconfig/"}]},{"title":"ESLint","slug":"ESLint","date":"2019-03-05T20:18:36.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/ESLint/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/ESLint/","excerpt":"","text":"ESLint 使用 安装 npm install eslint --save-dev 创建 eslint --init ESlint初始化后生成.eslintrc配置文件检查react使用eslint-plugin-react 使用1234567891011121314151617181920212223242526272829303132333435&#123; // 解析器 \"parser\": \"babel-eslint\", // 引用配置 用于react \"extends\": [ // ESlint官方配置 \"eslint:recommended\", //推荐的react配置 \"plugin:react/recommended\" ], // eslint-plugin-react 默认配置 \"settings\": &#123; \"react\": &#123; \"createClass\": \"createReactClass\", \"pragma\": \"React\" &#125;, \"propWrapperFunctions\": [\"forbidExtraProps\"] &#125;, // 规则 \"rules\": &#123; \"no-console\":\"off\", \"no-undef\":\"off\", \"react/display-name\":\"off\" &#125;&#125;/** eslint 检查 --ext 指定检查的扩展名和文件 --fix 运行自动修复，并不是所有都能修复 package.json文件 \"scripts\": &#123; \"lint\": \"eslint --ext .js src test\", \"lintX\":\"eslint --ext .js src test --fix\" &#125;,*/ 其余配置查看 ESLint官网","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"eslint","slug":"eslint","permalink":"http://blog.rensailong.top/tags/eslint/"}]},{"title":"mongoDB","slug":"mongoDB","date":"2019-03-05T20:16:50.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/mongoDB/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/mongoDB/","excerpt":"","text":"mongoDB 的使用 准备 解压下载的安装包 mongod 启动服务器进程 mongo 打开客户端的shell(命令行工具) bin 目录下新增文件 mongodb.config 在 mongodb.config 添加 dbpath=c:\\mongodb\\data (即data文件夹所在的目录) 在bin目录下运行命令行，windows 执行 ./mongod --config mongodb.config 基础 切换数据库 use learn，可用于创建 查看当前选择的库 db insert 插入 db.unicorns.insert({name: &#39;Aurora&#39;, gender: &#39;f&#39;, weight: 450}) ‘find’ 查看 得到一个文档列表 db.unicorns.find() 掌握选择器（selector） db.unicorns.find({gender: ‘m’, weight: {$gt: 700}})$lt 小于 $lte 小于或等于 $gt 大于 $gte 大于等于 $ne 等于db.unicorns.find({gender: &#39;m&#39;, weight: {$gt: 700}}) 查看 ‘gender等于m weight 大于700’ 的记录 $exists操作符用于匹配一个域是否存在db.unicorns.find({vampires: {$exists: false}}) $or 或 db.unicorns.find({gender: &#39;f&#39;, $or: [{loves: &#39;apple&#39;}, {loves: &#39;orange&#39;}, {weight: {$lt: 500}}]}) db.unicorns.remove() 删除操作db.unicorns.count() 记录数量 更新操作 update db.unicorns.update({name: &#39;Roooooodles&#39;}, {weight: 590})用后一个参数，替换前一个参数查到的记录内容仅需要替换其中的某个值 可以使用 $set 修饰符db.unicorns.update({weight: 590}, {$set: {name: &#39;Roooooodles&#39;, dob: new Date(1979, 7, 18, 18, 44), loves: [&#39;apple&#39;], gender: &#39;m&#39;, vampires: 99}})$inc 可以用来将一个域的值增加一个正的或负的数值db.unicorns.update({name: &#39;Pilot&#39;}, {$inc: {vampires: -2}})$push 添加一个新值 db.unicorns.update({name: &#39;Aurora&#39;}, {$push: {loves: &#39;sugar&#39;}})插新操作 即将 db.hits.update() 第三个参数true使用规则：当目标文档存在的时候，插新操作会更新该文档，否则就插入该新文档 多重更新 更改符合条件的所有记录 需要把第四个参数设置为true db.unicorns.update({}, {$set: {vaccinated: true }}, false, true); update的默认行为是只更新第一个找到的文档 查找 域的选择find还有第二个可选参数。该参数是一个列表，用户在这个表中指明要求find读取的域（相当于对要查询的字段进行指定）db.unicorns.find(null, {name: 1});排除默认显示的_id字段，{name:1, _id: 0}可以显式地从返回结果中排除它,只能排除_id,其他是非法的 比如: {_id:1, name:0}，就是非法的 排序db.unicorns.find().sort() 规则： 1升序 -1降序db.unicorns.find().sort({weight: -1}) 降序排序 分页分页可以通过limit以及skip这两个游标操作来实现db.unicorns.find().sort({weight: -1}).limit(2).skip(1) 技术对一个集合直接执行 countdb.unicorns.count({vampires: {$gt: 50}})","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.rensailong.top/tags/mongodb/"}]},{"title":"express-node-demo","slug":"express-node-demo","date":"2019-03-05T20:15:14.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/express-node-demo/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/express-node-demo/","excerpt":"","text":"express-node npm init 安装 express npm i express@4.14.0 --save supervisor 解决每次修改代码，重启服务问题 npm i -g supervisor 运行 supervisor index 启动程序 supervisor 会监听当前目录下 node 和 js 后缀的文件，当这些文件发生改动时，supervisor 会自动重启程序 路由 123456789101112const express = require('express')const app = express()app.get('/', function (req, res) &#123; res.send('hello, express')&#125;)app.get('/users/:name', function (req, res) &#123; res.send('hello, ' + req.params.name)&#125;)app.listen(3000) express.Router 123456789101112131415161718192021222324252627282930313233// index.js // 根目录const express = require('express')const app = express()const indexRouter = require('./routes/index')const userRouter = require('./routes/users')app.use('/', indexRouter)app.use('/users', userRouter)app.listen(3000)// routes/index.js router目录const express = require('express')const router = express.Router()router.get('/', function (req, res) &#123; res.send('hello, express')&#125;)module.exports = router// routes/users.js router目录const express = require('express')const router = express.Router()router.get('/:name', function (req, res) &#123; res.send('hello, ' + req.params.name)&#125;)module.exports = router 模板引擎 ejs 安装 npm i ejs --save 前端博客 目录结构123456models: 存放操作数据库的文件public: 存放静态文件，如样式、图片等routes: 存放路由文件views: 存放模板文件index.js: 程序主文件package.json: 存储项目名、描述、作者、依赖等等信息 安装项目的依赖模块1npm i config-lite connect-flash connect-mongo ejs express express-formidable express-session marked moment mongolass objectid-to-timestamp sha1 winston express-winston --save 对应模块的用处1234567891011121314express: web 框架express-session: session 中间件connect-mongo: 将 session 存储于 mongodb，结合 express-session 使用connect-flash: 页面通知的中间件，基于 session 实现ejs: 模板express-formidable: 接收表单及文件上传的中间件config-lite: 读取配置文件marked: markdown 解析moment: 时间格式化mongolass: mongodb 驱动objectid-to-timestamp: 根据 ObjectId 生成时间戳sha1: sha1 加密，用于密码加密winston: 日志express-winston: express 的 winston 日志中间件 ESlint1ESLint 是一个代码规范和语法错误检查工具。使用 ESLint 可以规范我们的代码书写，可以在编写代码期间就能发现一些低级错误 全局安装 eslintnpm i eslint -g 运行eslint --init 初始化 eslint 配置1234-&gt; Use a popular style guide-&gt; Standard-&gt; JSONeslint 会创建一个 .eslintrc.json 的配置文件，同时自动安装并添加相关的模块到 devDependencies。这里我们使用 Standard 规范，其主要特点是不加分号 ESLint 需要结合编辑器或 IDE 使用，如： Sublime Text 需要装两个插件：SublimeLinter + SublimeLinter-contrib-eslintVS Code 需要装一个插件：ESLint EditorConfig EditorConfig 是一个保持缩进风格的一致的工具，当多人共同开发一个项目的时候，往往会出现每个人用不同编辑器的情况，而且有的人用 tab 缩进，有的人用 2 个空格缩进，有的人用 4 个空格缩进，EditorConfig 就是为了解决这个问题而诞生EditorConfig 需要结合编辑器或 IDE 使用，如： Sublime Text 需要装一个插件：EditorConfigVS Code 需要装一个插件：EditorConfig for VS Code 使用 -&gt; 新建 .editorconfig 的文件 添加如下内容1234567891011121314151617# editorconfig.orgroot = true[*]indent_style = spaceindent_size = 2end_of_line = lfcharset = utf-8trim_trailing_whitespace = trueinsert_final_newline = truetab_width = 2[*.md]trim_trailing_whitespace = false[Makefile]indent_style = tab 使用 2 个空格缩进，tab 长度也是 2 个空格。trim_trailing_whitespace 用来删除每一行最后多余的空格，insert_final_newline 用来在代码最后插入一个空的换行。 配置文件不管是小项目还是大项目，将配置与代码分离是一个非常好的做法。我们通常将配置写到一个配置文件里，如 config.js 或 config.json ，并放到项目的根目录下。但实际开发时我们会有许多环境，如本地开发环境、测试环境和线上环境等，不同环境的配置不同（如：MongoDB 的地址），我们不可能每次部署时都要去修改引用 config.test.js 或者 config.production.js。config-lite 模块正是你需要的 config-lite config-lite 是一个轻量的读取配置文件的模块。config-lite 会根据环境变量（NODE_ENV）的不同加载 config 目录下不同的配置文件。如果不设置 NODE_ENV，则读取默认的 default 配置文件，如果设置了 NODE_ENV，则会合并指定的配置文件和 default 配置文件作为配置，config-lite 支持 .js、.json、.node、.yml、.yaml 后缀的文件。 如果程序以 NODE_ENV=test node app 启动，则 config-lite 会依次降级查找 config/test.js、config/test.json、config/test.node、config/test.yml、config/test.yaml 并合并 default 配置; 如果程序以 NODE_ENV=production node app 启动，则 config-lite 会依次降级查找 config/production.js、config/production.json、config/production.node、config/production.yml、config/production.yaml 并合并 default 配置。 新建配置文件 config/default.js123456789module.exports = &#123; port: 3000, session: &#123; secret: 'myblog', key: 'myblog', maxAge: 2592000000 &#125;, mongodb: 'mongodb://localhost:27017/myblog'&#125; 配置释义： port: 程序启动要监听的端口号session: express-session 的配置信息，后面介绍mongodb: mongodb 的地址，以 mongodb:// 协议开头，myblog 为 db 名 功能与路由设计 1234567891011121314151617181920212223功能及路由设计如下：注册 注册页：GET /signup 注册（包含上传头像）：POST /signup登录 登录页：GET /signin 登录：POST /signin 登出：GET /signout查看文章 主页：GET /posts 个人主页：GET /posts?author=xxx 查看一篇文章（包含留言）：GET /posts/:postId发表文章 发表文章页：GET /posts/create 发表文章：POST /posts/create修改文章 修改文章页：GET /posts/:postId/edit 修改文章：POST /posts/:postId/edit 删除文章：GET /posts/:postId/remove留言 创建留言：POST /comments 删除留言：GET /comments/:commentId/remove 由于我们博客页面是后端渲染的，所以只通过简单的 (GET) 和 (POST) 与后端进行交互，如果使用 jQuery 或者其他前端框架（如 Angular、Vue、React 等等）可通过 Ajax 与后端交互，则 api 的设计应尽量遵循 Restful 风格。 Restful Restful 是一种 api 的设计风格，提出了一组 api 的设计原则和约束条件。如上面删除文章的路由设计： GET /posts/:postId/removeRestful 风格的设计： DELETE /posts/:postId 会话1234567由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是会话（Session）。cookie 与 session 的区别cookie 存储在浏览器（有大小限制），session 存储在服务端（没有大小限制）通常 session 的实现是基于 cookie 的，session id 存储于 cookie 中session 更安全，cookie 可以直接在浏览器查看甚至编辑 我们通过引入 express-session 中间件实现对会话的支持：app.use(session(options)) session 中间件会在 req 上添加 session 对象，即 req.session 初始值为 {}，当我们登录后设置 req.session.user = 用户信息，返回浏览器的头信息中会带上 set-cookie 将 session id 写到浏览器 cookie 中，那么该用户下次请求时，通过带上来的 cookie 中的 session id 我们就可以查找到该用户，并将用户信息保存到 req.session.user 页面通知 123456789我们还需要这样一个功能：当我们操作成功时需要显示一个成功的通知，如登录成功跳转到主页时，需要显示一个 登陆成功 的通知；当我们操作失败时需要显示一个失败的通知，如注册时用户名被占用了，需要显示一个 用户名已占用 的通知。通知只显示一次，刷新后消失，我们可以通过 connect-flash 中间件实现这个功能。connect-flash 是基于 session 实现的，它的原理很简单：设置初始值 req.session.flash=&#123;&#125;，通过 req.flash(name, value) 设置这个对象下的字段和值，通过 req.flash(name) 获取这个对象下的值，同时删除这个字段，实现了只显示一次刷新后消失的功能。express-session、connect-mongo 和 connect-flash 的区别与联系express-session: 会话（session）支持中间件connect-mongo: 将 session 存储于 mongodb，需结合 express-session 使用，我们也可以将 session 存储于 redis，如 connect-redisconnect-flash: 基于 session 实现的用于通知功能的中间件，需结合 express-session 使用 权限控制不管是论坛还是博客网站，我们没有登录的话只能浏览，登陆后才能发帖或写文章，即使登录了你也不能修改或删除其他人的文章，这就是权限控制。我们也来给博客添加权限控制，如何实现页面的权限控制呢？我们可以把用户状态的检查封装成一个中间件，在每个需要权限控制的路由加载该中间件，即可实现页面的权限控制。在 myblog 下新建 middlewares 目录，在该目录下新建 check.js，添加如下代码 用户模型设计 只存储用户的名称、密码（加密后的）、头像、性别和个人简介这几个字段lib/mongo.js 12345678exports.User = mongolass.model('User', &#123; name: &#123; type: 'string' &#125;, password: &#123; type: 'string' &#125;, avatar: &#123; type: 'string' &#125;, gender: &#123; type: 'string', enum: ['m', 'f', 'x'] &#125;, bio: &#123; type: 'string' &#125;&#125;)exports.User.index(&#123; name: 1 &#125;, &#123; unique: true &#125;).exec()// 根据用户名找到用户，用户名全局唯一 注册页 新建 views/signup.ejs 注册与文件上传 使用 express-formidable 处理 form 表单 （包括文件上传） 修改 index.js 12345// 处理表单及文件上传的中间件app.use(require('express-formidable')(&#123; uploadDir: path.join(__dirname, 'public/img'), // 上传文件目录 keepExtensions: true// 保留后缀&#125;)) 使用 express-formidable 处理表单的上传，表单普通字段挂载到 req.fields 上，表单上传后的文件挂载到 req.files 上，文件存储在 public/img 目录下。然后校验了参数，校验通过后将用户信息插入到 MongoDB 中，成功则跳转到主页并显示『注册成功』的通知，失败（如用户名被占用）则跳转回注册页面并显示『用户名已被占用』的通知","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"express","slug":"express","permalink":"http://blog.rensailong.top/tags/express/"}]},{"title":"前端工具集","slug":"前端工具集","date":"2019-03-05T20:12:24.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/前端工具集/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/前端工具集/","excerpt":"","text":"工具12345678910111213141、图片生成器：http://placebox.es/500/300 2、可视化布局器：http://www.bootcss.com/p/layoutit/ 3、响应式布局器：http://www.responsivewebcss.com/ 4、新浪开发平台：http://open.weibo.com/connect 5、雅虎图片压缩工具：http://www.smushit.com/ysmush.it/ 6、CSS3属性查询：http://ued.ctrip.com/blog/wp-content/webkitcss/index.html 7、前端api集：http://overapi.com/ 8、在线协作作图：http://www.processon.com/ 9、虚拟机配置：http://www.g7blogs.com/?p=618 10、前端工具导航条：http://f2e.im/static/pages/nav/index.html#6755344-tsina-1-50251-72fb614e7130783e23f259bf5de6db3a 11、图表类：http://ecomfe.github.io/echarts/doc/example/radar2.html 12、Jsonp处理：http://www.g7blogs.com/?p=821 13、瀑布流：http://www.g7blogs.com/?p=728 14、bootstrap：http://ninghao.net/bootstrap/index.html 站点123456789101112131415161、腾讯游戏设计团队：http://tgideas.qq.com/ 2、html5研究小组：http://www.mhtml5.com/ 3、网易邮箱前端技术中心：http://ntesmailfetc.blog.163.com/ 4、web前端--人人小站：http://zhan.renren.com/webqdjs?from=template&amp;checked=true 5、腾讯全端Alloy Team：http://www.alloyteam.com/ 6、携程UED：http://ued.ctrip.com/blog/ 7、微博UED：http://udc.weibo.com/ 8、网易用户体验设计中心：http://uedc.163.com/ 9、新浪UED：http://ued.sina.com/ 10、ISUX腾讯：http://isux.tencent.com/ 11、网站导航：http://hao.uisdc.com/ 12、淘宝UED：http://ued.taobao.com/blog/ 13、站酷：http://www.zcool.com.cn/ 14、优设网：http://www.uisdc.com/ 15、CSS3创意分享：http://ecd.tencent.com/css3/index.html http://www.csswinner.com/ 内部12345678910111、NIE官网架构表：http://nx.netease.com/guide/dir.html 2、案例库：http://192.168.22.64:9003/index.html 3、常见问题：http://nx.netease.com/web/ 4、投票系统：http://cgi.mmog.163.com:8088/account/login 5、新闻发布系统：https://cms.netease.com:8443/index.html 6、强刷系统：https://cacheadmin.x.netease.com:8080/index/ 7、文章页代码规划：http://res.nie.netease.com/tx3/gw/11v1/important/art.html#p1 8、拖动生成专题器：http://tools.g7blogs.com/xy2 9、点赞组件：http://jeffcz.github.io/NIE-iLike/ 10、直邮自动化工具：http://res.nie.netease.com/comm/edm/ 11、评论系统：http://xy3.163.com/2014/jiehun/fcwr/comment.html","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.rensailong.top/categories/工具/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/tags/前端/"}]},{"title":"正则","slug":"正则","date":"2019-03-05T20:09:55.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/正则/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/正则/","excerpt":"","text":"正则 直接量字符 123456789\\0 匹配null字符（\\u0000）。 [\\b]匹配退格键(\\u0008)，不要与\\b混淆。 \\t 匹配制表符tab（\\u0009）。 \\n 匹配换行键(\\u000A)。 \\v 匹配垂直制表符（\\u000B）。 \\f 匹配换页符（\\u000C）。\\r 匹配回车键(\\u000D)。 \\xnn匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。 \\uxxx匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的unicode字符。 \\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。 字符类 12345678910[...] 方括号内的任意字符 [^...] 不在方括号内的任意字符 . 除换行符和其他Unicode行终止符之外的任意字符 \\w 任何ASCII字符组成的单词，等价于[a-zA-Z0-9] \\W 任何不适ASCII字符组成的单词，等价于[^a-zA-Z0-9] \\s 任何Unicode空白符 \\S 任何非Unicode空白符的字符 \\d 任何非ASCII数字，等价于[0-9] \\D 除了ASCII数字之外的任何字符，等价于[^0-9] [\\b] 退格直接量 重复 123456&#123;n,m&#125; 匹配前一项至少n次，至多m次 &#123;n,&#125; 匹配前一项n次或者更多次，也可以说至少n次 &#123;n&#125; 匹配前一项n次 ? 匹配前一项0次或者1次，等价于&#123;0,1&#125; + 匹配前一项1次或多次，等价于&#123;1,&#125; * 匹配前一项0次或多次，等价于&#123;0,&#125; 贪婪和非贪婪 123456// 贪婪匹配var a1 = /a+/.exec(&apos;aaa&apos;);console.log(a1);// 非贪婪重复var a2 = /a+?/.exec(&apos;aaa&apos;);console.log(a2); 选择、组合、引用 1234567891011121314151617181920| 选择，匹配的是该符号左边的子表达式或右边的子表达式(...) 组合，将几个项组合为一个单位，这个单位可通过“*”、“+”、“?”和“|”等符号加以修饰，而且可以记住和这个组合相匹配的字 符串以供此后的引用使用(?...) 只组合，把项组合到一个单位，但不记忆与该组相匹配的字符 \\n 和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式（也有可能是嵌套的），组索引是从左到右的左括号数，“(?:”形 式的分组不编码// 选择、分组、引用// 1.字符“|”用于分隔供选择的字符// 2.圆括号“()”可以把单独的项组合成子表达式// 另一个用途是允许在同一正则表达式的后部引用前面的子表达式，如下：// var a3 = /(.)b(.)\\1b\\2/.test(&apos;abcabc&apos;);// console.log(a3); // true// 注意：因为子表达式可以嵌套另一个子表达式，所以引用的位置是参与计数的左括号的位置。比如： (s(ss))，\\2表示的是(ss)。var a4 = /(a|b)c\\1/.test(&apos;aca&apos;); console.log(a4); // truevar a5 = /(a|b)c\\1/.test(&apos;acb&apos;);console.log(a5); // false// 由于(a|b)匹配的是a，所以\\1所对应的也应该是a。// 注意：对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是那个模式相匹配的文 本的引用 指定匹配位置 123456789101112131415^ 匹配字符串的开头，在多行检索中，匹配一行的开头 $ 匹配字符串的结尾，在多行检索中，匹配一行的结尾 \\b 匹配一个单词的边界 \\B 匹配非单词边界的位置 (?=p) 零宽正向先行断言，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符 (?!p) 零宽负向先行断言，要求接下来的字符不与p匹配(?:) 非获取匹配，匹配冒号后的内容但不获取匹配结果，不进行存储供以后使用。 var m = &quot;abcabc&quot;.match(/(?:a)(b)(c)/) //结果 [&quot;abc&quot;, &quot;b&quot;, &quot;c&quot;] // m[0] 是/(?:a)(b)(c)/匹配到的整个字符串，这里包括了a // m[1] 是捕获组1，即(b)匹配的子字符串substring or sub sequence // m[2] 是捕获组2，即(c)匹配到的 var m = &quot;abcabc&quot;.match(/(a)(b)(c)/) //结果 [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 修饰符 123i 执行不区分大小写的匹配g 执行一个全局匹配，即找到所有的匹配，而不是在找到第一个之后就停止 m 多行模式匹配，在这种模式下，如果待检索的字符串包含多行，那么^和$锚字符除了匹配整个字 符串的开始和结尾之外，还能匹配每行的开始和结尾 模式匹配的string方法 12345678910111213141516171819202122232425262728293031323334353637search()：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位 置，如果找不到匹配的子串，将返回-1。 match()：返回一个数组，成员是所有匹配的子字符串。 replace()：按照给定的正则表达式进行替换，返回替换后的字符串。split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员// string 匹配方法1.search// var a6 = &apos;javascript&apos;.search(/script/i); // 4 返回匹配字符串起始第一个字符位置，否则返回-1// console.log(a6);2. match()// var a7 = &apos;1 plus 2 equals 3&apos;.match(/\\d+/g);// console.log(a7); // [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot; ]// 参数为正则，返回匹配结果组成的数组3.replace// var a8 = &apos;hello world&apos;.replace(/(\\w+)\\s(\\w+)/, &apos;$2 $1&apos;);// console.log(a8); //world hello$` 指代匹配结果前面的文本。 $&apos; 指代匹配结果后面的文本。 $n 指代匹配成功的第n组内容，n是从1开始的自然数。 $$ 指代美元符号$。4.split// split 参数可以是一个正则表达式// var a10 = &apos;1,2,3,4&apos;.split(/,/g); // console.log(a10);// RegExp对象// 正则方法// 1. exec() 作用，返回所有匹配的子串，返回的是一个数组// var a11 = /a|b|c/.exec(&apos;abc&apos;);// console.log(a11); [&apos;a&apos;];// 2.test() 正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://blog.rensailong.top/tags/正则/"}]},{"title":"nvm","slug":"nvm","date":"2019-03-05T20:07:20.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/nvm/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/nvm/","excerpt":"","text":"1. 安装1https://github.com/coreybutler/nvm-windows/releases 2. 安装完成以后需要进行配置123456789/***node下载源*/nvm node_mirror https://npm.taobao.org/mirrors/node//***npm下载源*/nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 3.常用命令123456789101112131415nvm arch 查看当前系统的位数和当前nodejs的位数nvm install &lt;version&gt; [arch] 安装制定版本的node 并且可以指定平台 version 版本号 arch 平台nvm list [available] - nvm list 查看已经安装的版本 - nvm list installed 查看已经安装的版本 - nvm list available 查看网络可以安装的版本nvm on 打开nodejs版本控制nvm off 关闭nodejs版本控制nvm proxy [url] 查看和设置代理nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是：https://github.com/npm/npm/archive/.nvm uninstall &lt;version&gt; 卸载制定的版本nvm use [version] [arch] 切换制定的node版本和位数nvm root [path] 设置和查看root路径nvm version 查看当前的版本","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"http://blog.rensailong.top/tags/nvm/"},{"name":"工具","slug":"工具","permalink":"http://blog.rensailong.top/tags/工具/"}]},{"title":"vim常用命令","slug":"vim常用命令","date":"2019-03-05T20:05:17.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/vim常用命令/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/vim常用命令/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738切换到编辑状态i切换到命令状态ESC保存:w退出:q保存并退出:wq退出不保存:q!删除字符x删除光标处到单词词尾dw删除光标处到行尾d$删除光标所在行dd撤销u粘贴p替换光标处字符dd先输入 r，再输出一个字符","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.rensailong.top/categories/工具/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://blog.rensailong.top/tags/vim/"}]},{"title":"翻墙","slug":"翻墙","date":"2019-03-05T19:50:31.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/翻墙/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/翻墙/","excerpt":"","text":"倚天剑逗比根据地ssr中文网","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.rensailong.top/categories/工具/"}],"tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://blog.rensailong.top/tags/翻墙/"},{"name":"ssr","slug":"ssr","permalink":"http://blog.rensailong.top/tags/ssr/"}]},{"title":"linux基础入门","slug":"linux基础入门","date":"2019-03-05T19:48:15.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/linux基础入门/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/linux基础入门/","excerpt":"","text":"目录操作 创建目录 1mkdir $HOME/testFolder 切换目录 使用cd命令切换目录 1cd $HOME/testFolder 使用cd ../命令切换到上一级目录 1cd ../ 移动目录 使用mv命令移动目录1mv $HOME/testFolder /var/tmp 删除目录 使用rm -rf命令删除目录1rm -rf /var/tmp/testFolder 查看目录下的文件 使用ls命令查看/etc目录下所有文件的文件夹1ls /etc 文件操作 创建文件 使用touch命令创建文件 1touch ~/testFile 执行ls命令，可以看到刚才新建的testFilder文件 1ls ~ 复制文件 使用cp命令复制文件1cp ~/testFile ~/testNewFile 删除文件使用rm命令删除文件，输入y后回车确认删除 1rm ~/testFile 查看文件内容 使用cat命令查看.bash_history文件内容1cat ~/.bash_history 过滤、管道与重定向 过滤 过滤出 /etc/passwd 文件中包含 root 的记录 1grep &apos;root&apos; /etc/passwd 递归地过滤出 /var/log/ 目录中包含 linux 的记录 1grep -r &apos;linux&apos; /var/log/ 管道 简单来说, Linux 中管道的作用是将上一个命令的输出作为下一个命令的输入, 像 pipe 一样将各个命令串联起来执行, 管道的操作符是 |比如, 我们可以将 cat 和 grep 两个命令用管道组合在一起 1cat /etc/passwd | grep &apos;root&apos; 过滤出 /etc 目录中名字包含 ssh 的目录(不包括子目录) 1ls /etc | grep &apos;ssh&apos; 重定向 可以使用 &gt; 或 &lt; 将命令的输出重定向到一个文件中1echo &apos;Hello World&apos; &gt; ~/test.txt 运维常用命令 ping 命令 对cloud.tencent.com发送 4 个 ping 包, 检查与其是否联通1ping -c 4 cloud.tencent.com netstat 命令 netstat 命令用于显示各种网络相关信息，如网络连接, 路由表, 接口状态等等 列出所有处于监听状态的tcp端1netstat -lt - 查看所有的端口信息, 包括 PID 和进程名称 1netstat -tulpn ps 命令 过滤得到当前系统中的 ssh 进程信息1ps aux | grep &apos;ssh&apos;","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.rensailong.top/tags/linux/"}]},{"title":"nginx静态服务器","slug":"nginx静态服务器","date":"2019-03-05T19:46:36.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/nginx静态服务器/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/nginx静态服务器/","excerpt":"","text":"安装nginx 在 CentOS 上，可直接使用 yum 来安装 Nginx 1yum install nginx -y 安装完成后，使用 nginx 命令启动 Nginx： 1nginx 此时，访问 http://111.231.56.173(服务器的公网域名) 可以看到 Nginx 的测试页面 配置静态服务器访问路径 外网用户访问服务器的 Web 服务由 Nginx 提供，Nginx 需要配置静态资源的路径信息才能通过 url 正确访问到服务器上的静态资源。打开 Nginx 的默认配置文件 /etc/nginx/nginx.conf ，修改 Nginx 配置，将默认的 root /usr/share/nginx/html; 修改为: root /data/www;，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /data/www; include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; 配置文件将 /data/www/static 作为所有静态资源请求的根路径，如访问: http://111.231.56.173/static/index.js，将会去 /data/www/static/ 目录下去查找 index.js。现在我们需要重启 Nginx 让新的配置生效，如： 1nginx -s reload 重启后，现在我们应该已经可以使用我们的静态服务器了，现在让我们新建一个静态文件，查看服务是否运行正常。首先让我们在 /data 目录 下创建 www 目录，如： 1mkdir -p /data/www 创建第一个静态网站 在 /data/www 目录下创建我们的第一个静态文件 index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;第一个静态文件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello world！&lt;/body&gt;&lt;/html&gt; 现在访问 http://111.231.56.173/index.html 应该可以看到页面输出 Hello world!","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog.rensailong.top/tags/部署/"},{"name":"nginx","slug":"nginx","permalink":"http://blog.rensailong.top/tags/nginx/"}]},{"title":"linux下部署express","slug":"linux下部署express","date":"2019-03-05T19:38:03.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/linux下部署express/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/linux下部署express/","excerpt":"","text":"安装基础软件 安装nginx 1yum install nginx -y 安装node 安装nvm nvm 安装npm加速1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 Express 安装 Express 生成器 1cnpm install express-generator -g 创建一个 express 站点 接下来，我们来创建一个 express 站点， 执行如下命令，来初始化一个新的以 cloud 为名的应用， 12cd /home/express cloud 初始化完成后，进入到目录中，安装对应的依赖 12cd cloud cnpm install 测试express 执行如下命令，来启动 Express ，进行测试 1DEBUG=cloud:* npm start 此时，我们可以打开浏览器，访问 http://111.231.56.173:3000 就可以访问默认的 Express 界面的内容。 安装pm2 1npm i pm2 -g 安装完成后，执行命令，为我们的 pm2 添加开机自启动 12pm2 startup systemd pm2 save 使用 PM2 启动 Express 执行如下命令，来使用 pm2 来启动我们的 express1pm2 start ./bin/www 接下来，我们来创建 Nginx 配置文件(/etc/nginx/conf.d/cloud.conf)，用于对 Express 进行反向代理，在文件中添加如下代码 123456789101112131415161718192021upstream cloud-app&#123;server 127.0.0.1:3000;keepalive 64;&#125;server&#123; listen 80; server_name 111.231.56.173; root /home/cloud; location / &#123; proxy_set_header HOST $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_pass http://cloud-app/; proxy_redirect off; proxy_read_timeout 240s; &#125;&#125; 添加完成后执行 nginx -t 来检测配置文件是否正常。 如果没有报错，就执行 nginx -s reload (在nginx的目录下重启) 来让重新加载配置文件。","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog.rensailong.top/tags/部署/"},{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/tags/前端/"},{"name":"express","slug":"express","permalink":"http://blog.rensailong.top/tags/express/"}]},{"title":"使用serve部署网站","slug":"使用serve部署网站","date":"2019-03-05T19:36:34.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/使用serve部署网站/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/使用serve部署网站/","excerpt":"","text":"安装pm2 1npm i pm2 -g 安装完成后，执行命令，为我们的 pm2 添加开机自启动 12pm2 startup systemd pm2 save 安装serve 1npm i pm2 -g 编写pm2配置文件，就叫pm2.config.js吧 1234567891011const path = require(&apos;path&apos;);module.exports = &#123; apps: [ &#123; name: &apos;music-app&apos;, script: &apos;/root/app/nodejs/lib/node_modules/serve/bin/serve.js&apos;, args: &apos;-p 5000 -s build&apos;, &#125; ]&#125; 启动pm2 1pm2 start pm2.config.js 简单配置nginx 123456789server &#123; listen 80; server_name music.rensailong.top; location / &#123; proxy_pass http://127.0.0.1:5000/; &#125; &#125; 然后通过music.rensailong.top就能访问到你部署在5000端口的网站了","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://blog.rensailong.top/tags/部署/"},{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/tags/前端/"},{"name":"react","slug":"react","permalink":"http://blog.rensailong.top/tags/react/"}]},{"title":"音乐app笔记","slug":"音乐app笔记","date":"2019-03-05T16:10:34.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/03/05/音乐app笔记/","link":"","permalink":"http://blog.rensailong.top/2019/03/05/音乐app笔记/","excerpt":"","text":"项目地址github自定义react官方脚手架(create-react-app) 使用rewire模块 1yarn add rewire proxyquire --dev 配置方法 新建scripts文件夹 在scripts下新建customized-build.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* 本模块运行react-scripts里的脚本 (Create React App) 可以自定义webpack配置，通过在项目根目录创建\"overrides-config.dev.js\" 、 \"overrides-config.prod.js\" 文件. A config-overrides file should export a single function that takes a config and modifies it as necessary. module.exports = function(webpackConfig) &#123; webpackConfig.module.rules[0].use[0].options.useEslintrc = true; &#125;;*/var rewire = require('rewire');var proxyquire = require('proxyquire');switch(process.argv[2]) &#123; // The \"start\" script is run during development mode case 'start': rewireModule('react-scripts/scripts/start.js', loadCustomizer('./overrides-config.dev')); break; // The \"build\" script is run to produce a production bundle case 'build': rewireModule('react-scripts/scripts/build.js', loadCustomizer('./overrides-config.prod')); break; // The \"test\" script runs all the tests with Jest case 'test': // Load customizations from the config-overrides.testing file. // That file should export a single function that takes a config and returns a config let customizer = loadCustomizer('./overrides-config.testing'); proxyquire('react-scripts/scripts/test.js', &#123; // When test.js asks for '../utils/createJestConfig' it will get this instead: '../utils/createJestConfig': (...args) =&gt; &#123; // Use the existing createJestConfig function to create a config, then pass // it through the customizer var createJestConfig = require('react-scripts/utils/createJestConfig'); return customizer(createJestConfig(...args)); &#125; &#125;); break; default: console.log('customized-build only supports \"start\", \"build\", and \"test\" options.'); process.exit(-1);&#125;// Attempt to load the given module and return null if it fails.function loadCustomizer(module) &#123; try &#123; return require(module); &#125; catch(e) &#123; if(e.code !== \"MODULE_NOT_FOUND\") &#123; throw e; &#125; &#125; // If the module doesn't exist, return a // noop that simply returns the config it's given. return config =&gt; config;&#125;function rewireModule(modulePath, customizer) &#123; // Load the module with `rewire`, which allows modifying the // script's internal variables. let defaults = rewire(modulePath); // Reach into the module, grab its global 'config' variable, // and pass it through the customizer function. // The customizer should *mutate* the config object, because // react-scripts imports the config as a `const` and we can't // modify that reference. let config = defaults.__get__('config'); customizer(config); 配置css预处理语言stylus 安装yarn add stylus stylus-loader --dev1234567891011121314module.exports = function(config) &#123; // Use your ESLint /*let eslintLoader = config.module.rules[0]; eslintLoader.use[0].options.useEslintrc = true;*/ // Add the stylus loader second-to-last // (last one must remain as the \"file-loader\") let loaderList = config.module.rules[1].oneOf; loaderList.splice(loaderList.length - 1, 0, &#123; test: /\\.styl$/, use: [\"style-loader\", \"css-loader\", \"stylus-loader\"] &#125;);&#125;; 新建 overrides-config.prod.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const paths = require('react-scripts/config/paths');const ExtractTextPlugin = require('extract-text-webpack-plugin');// Webpack uses `publicPath` to determine where the app is being served from.// It requires a trailing slash, or the file assets will get an incorrect path.const publicPath = paths.servedPath;// Some apps do not use client-side routing with pushState.// For these, \"homepage\" can be set to \".\" to enable relative asset paths.const shouldUseRelativeAssetPaths = publicPath === './';const cssFilename = 'static/css/[name].[contenthash:8].css';const extractTextPluginOptions = shouldUseRelativeAssetPaths ? // Making sure that the publicPath goes back to to build folder. &#123; publicPath: Array(cssFilename.split('/').length).join('../') &#125; : &#123;&#125;;module.exports = function(config) &#123; // Use your ESLint /*let eslintLoader = config.module.rules[0]; eslintLoader.use[0].options.useEslintrc = true;*/ // Add the stylus loader second-to-last // (last one must remain as the \"file-loader\") let loaderList = config.module.rules[1].oneOf; loaderList.splice(loaderList.length - 1, 0, &#123; test: /\\.styl$/, loader: ExtractTextPlugin.extract( Object.assign( &#123; fallback: &#123; loader: require.resolve('style-loader'), options: &#123; hmr: false &#125; &#125;, use: [ &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, minimize: true, sourceMap: true &#125; &#125;, &#123; loader: require.resolve('stylus-loader') &#125; ] &#125; ), extractTextPluginOptions) &#125;);&#125;; 修改启动脚本 123456\"scripts\": &#123; \"start\": \"node scripts/customized-build start\", \"build\": \"node scripts/customized-build build\", \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" &#125; 加入autoprefixer 安装yarn add poststylus --dev123456789101112131415161718192021222324// 新建overrides-config.base.js配置文件，增加poststylus插件配置const webpack = require('webpack');const poststylus = require('poststylus');const autoprefixer = require('autoprefixer');module.exports.stylusLoaderOptionsPlugin = new webpack.LoaderOptionsPlugin(&#123; options: &#123; stylus: &#123; use: [ poststylus([ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;) ]) ] &#125; &#125; &#125;); 项目配置根路径别名 123456789// overrides-config.base.js 文件中增加这样的代码const path = require('path');..........function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports.rootPath = resolve('src'); QQ音乐接口 123456789* 轮播接口 https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg? g_tk=964895631&amp;uin=1121352970&amp;format=json&amp;inCharset=utf-8&amp; outCharset=utf-8&amp;notice=0&amp;platform=h5&amp;needNewCode=1&amp;_=1516501673247* 音乐列表接口https://u.y.qq.com/cgi-bin/musicu.fcg? callback=getUCGI10455592910292011&amp;g_tk=964895631&amp;jsonpCallback=getUCGI10455592910292011&amp;loginUin=1121352970&amp;hostUin=0&amp; format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0&amp; data=%7B%22albumlib%22%3A%7B%22method%22%3A%22get_album_by_tags%22%2C%22param%22%3A%7B%22area%22%3A7%2C%22company%22%3A-1%2C%22genre%22%3A-1%2C%22type%22%3A-1%2C%22year%22%3A-1%2C%22sort%22%3A2%2C%22get_tags%22%3A1%2C%22sin%22%3A0%2C%22num%22%3A20%2C%22click_albumid%22%3A0%7D%2C%22module%22%3A%22music.web_album_library%22%7D%7D JSONP使用 安装 yarn add jsonp 轮播插件 swiper 安装 npm install swiper@3.4.2 --save 官网 滑屏 Better-Scroll 安装 npm install better-scroll@1.5.5 --save github地址 优化图片加载 图片懒加载 使用react-lazyload ， 地址 github 安装 npm install react-lazyload --save 实现动画 react-transition-group 动画库 详情1234// CSSTransition接受in、timeout、classNames三个props。// 其中in控制组件的状态。// 当in为true时，组件的子元素会应用translate-enter、translate-enter-active样式，当in为false时，// 组件的子元素会应用translate-exit、translate-exit-active样式。timeout指定过渡时间 学习到的东西 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788891. e.stopPropagation() // 阻止事件冒泡2. e.preventDefault() // 禁用浏览器默认行为3. return false 相当于 1和24. style计算属性 /** * 获取css属性值 * @param oElement 节点 * @param sName 属性名 * @returns &#123;*&#125; */ function getStyle(oElement, sName)&#123; // currentStyle ie // getComputedStyle 其它 return oElement.currentStyle ? oElement.currentStyle[sName] : getComputedStyle(oElement, null)[sName]; &#125; 5. rem (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; if(clientWidth&gt;=750)&#123; docEl.style.fontSize = '100px'; &#125;else&#123; docEl.style.fontSize = 100 * (clientWidth / 750) + 'px'; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window);7. 使用rem后，获取元素宽度高度的问题？// html font-size: 50px;&lt;style&gt; #wrapper&#123; width: 2rem; height: 2rem; background-color: aqua;font-size: 20px;&#125;&lt;/style&gt;&lt;div id=\"wrapper\" style=\"width: 2rem;\"&gt; demo&lt;/div&gt;&lt;script&gt;// 实际元素宽度应该是 100px, 但是却是32px var wrapperDom = document.querySelector('#wrapper'); console.log(wrapperDom.offsetWidth); // 32 console.log(getStyle(wrapperDom, 'width')); //32px&lt;/script&gt;6. class类模型的使用 class Song &#123; constructor(id, mId, name, img, duration, url, singer) &#123; this.id = id; this.mId = mId; this.name = name; this.img = img; this.duration = duration; this.url = url; this.singer = singer &#125; &#125;7. jsonp使用 jsonp(url, option, callback);option -&gt; &#123; param: 'callback', name: '给后台的回调名称', prefix: 'name相同，后面回家数字'&#125;// url = ...?param=nameajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域 8. 深浅拷贝var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== 'object')&#123; return; &#125; else if(window.JSON)&#123; // JSON解析 str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; // 递归解析？ newobj[i] = typeof obj[i] === 'object' ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;;ES6 浅拷贝Object.assign() 方法可以把任意多个的源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象.浅：Object.assign(&#123;&#125;, obj) // 只拷贝自身和可枚举属性","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/tags/前端/"},{"name":"react","slug":"react","permalink":"http://blog.rensailong.top/tags/react/"}]},{"title":"travis-cli","slug":"travis-cli","date":"2019-02-22T10:58:51.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/02/22/travis-cli/","link":"","permalink":"http://blog.rensailong.top/2019/02/22/travis-cli/","excerpt":"","text":"travis-cli的简单使用 https://www.jianshu.com/p/e6852a547f4c参考 我自己的配置travis.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445language: node_jsnode_js: stable#cachecache: directories: - &quot;node_modules&quot;# 通知notifications: email: recipients: - 1121352970@qq.com on_success: never on_failure: always# 指定分支# branches:# only:# - developbefore_install:- npm install -g hexo- npm install -g hexo-cliinstall:- npm installscript:- hexo clean- hexo generateafter_success: # - hexo deploy 报错 - cd ./public - git init - git config --global user.name &apos;成雨&apos; - git config --global user.email &apos;1121352970@qq.com&apos; - git add . - git commit -m &quot;generate static resources, triggerd by travis ci&quot; - git push --force &quot;https://aikeProject:$&#123;REPO_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master# 指定环境变量env: global: - GH_REF: github.com/aikeProject/aikeProject.github.io.git","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.rensailong.top/categories/前端/"}],"tags":[{"name":"构建","slug":"构建","permalink":"http://blog.rensailong.top/tags/构建/"}]},{"title":"docker使用","slug":"docker使用","date":"2019-02-21T19:46:14.000Z","updated":"2019-03-13T16:36:34.117Z","comments":true,"path":"2019/02/21/docker使用/","link":"","permalink":"http://blog.rensailong.top/2019/02/21/docker使用/","excerpt":"","text":"安装docker (使用的是腾讯云主机) yum install docker-io -y docker -v 查看版本 service docker start 启动docker chkconfig docker on 设置开机自启 配置docker 因为国内访问 Docker Hub 较慢, 可以使用腾讯云提供的国内镜像源, 加速访问 Docker Hub 依次执行以下命令 echo &quot;OPTIONS=&#39;--registry-mirror=https://mirror.ccs.tencentyun.com&#39;&quot; &gt;&gt; /etc/sysconfig/docker systemctl daemon-reload service docker restart docke命令 docke docker info 查看Docker是否安装正确 docker images 查看镜像列表 docker ps 查看容器列表 sudo docker pull busybox 拉取一个叫做busybox的镜像 docker logs 查看日志 删除容器 docker stop [id] docker rm [id] docker commit $sample_job job1 将容器的状态保存为镜像` docker search name 查找镜像 docker history (image_name) 查看镜像的历史版本 docker push (image_name) 将镜像推送到registry Dockerfile Dockerfile所有Dockerfile都必须以FROM命令开始。 FROM命令会指定镜像基于哪个基础镜像创建，接下来的命令也会基于这个基础镜像（译者注：CentOS和Ubuntu有些命令可是不一样的）。FROM命令可以多次使用，表示会创建多个镜像1FROM &lt;image name&gt; Dockerfile命令 1.MAINTAINER：设置该镜像的作者1MAINTAINER &lt;author name&gt; 2.RUN：在shell或者exec的环境下执行的命令。RUN指令会在新创建的镜像上添加新的层面，接下来提交的结果用在Dockerfile的下一条指令中1RUN &lt;command&gt; 3.ADD：复制文件指令。它有两个参数和。destination是容器内的路径。source可以是URL或者是启动配置上下文中的一个文件1ADD &lt;src&gt; &lt;destination&gt; 4.CMD：提供了容器默认的执行命令。 Dockerfile只允许使用一次CMD指令。 使用多个CMD会抵消之前所有的指令，只有最后一个指令生效。 CMD有三种形式：123CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]CMD [&quot;param1&quot;,&quot;param2&quot;]CMD command param1 param2 5.EXPOSE：指定容器在运行时监听的端口。语法如下：1EXPOSE &lt;port&gt;; 6.ENTRYPOINT：配置给容器一个可执行的命令，这意味着在每次使用镜像创建容器时一个特定的应用程序可以被设置为默认程序。同时也意味着该镜像每次被调用时仅能运行指定的应用。类似于CMD，Docker只允许一个ENTRYPOINT，多个ENTRYPOINT会抵消之前所有的指令，只执行最后的ENTRYPOINT指令。语法如下：12ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;]ENTRYPOINT command param1 param2 7.WORKDIR：指定RUN、CMD与ENTRYPOINT命令的工作目录1WORKDIR /path/to/workdir 8.ENV：设置环境变量。它们使用键值对，增加运行程序的灵活性1ENV &lt;key&gt; &lt;value&gt; USER：镜像正在运行时设置一个UID 1USER &lt;uid&gt; VOLUME：授权访问从容器内到主机上的目录 1VOLUME [&quot;/data&quot;] 11.更多命令例如123456789101112131415FROM nodeMAINTAINER ChengYu &quot;https://github.com/aikeProject&quot;# 优先将 ./package.json 复制到镜像中，预先加载第三方依赖COPY . /app/WORKDIR /appRUN npm i# 暴露3000端口EXPOSE 3000CMD npm start","categories":[{"name":"后端","slug":"后端","permalink":"http://blog.rensailong.top/categories/后端/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.rensailong.top/tags/docker/"}]}]}